# 1.8.0更新说明文档

**说明：本文档适用于PTA 1.7.1版本的更新升级，如果您项目中的版本过低，请按照之前的升级文档一步一步进行升级操作。**

## 本次升级所带来的优化内容

1、<a href="###证书更新" title="证书"> HTTPS证书更新</a>

2、<a href="###库的更新" title="库的更新">库的更新</a>

3、<a href="###头发物理效果优化" title="效果优化">头发物理效果优化</a>

4、<a href="###更新素材" title="更新素材">更新素材</a>

5、 <a href="###sta-tts 升级到最新的版本" title="sta-tts">sta-tts 升级到最新的版本</a>

6、<a href="###模型缩放改为相机bundle控制" title="模型缩放改为相机bundle控制">模型缩放改为相机bundle控制</a>

7、<a href="###界面逻辑修改" title="界面逻辑修改">界面逻辑修改</a>

8、<a href="###表情包预览界面的宽高修改" title="表情包预览界面的宽高修改">表情包预览界面的宽高修改</a>

9、<a href="###更新相机动画控制" title="更新相机动画控制">更新相机动画控制</a>

### HTTPS证书更新

#### 资源更新

+ 删除pta_api2.pem

#### 代码改动部分

**服务器证书更新逻辑**

**初始化 `FUApplication.java`**

```java
boolean isHttps = OkHttpUtils.initNet();
OkHttpUtils.initOkHttpUtils(OkHttpUtils.initOkHttpClient(this, isHttps));
```

**去除pta_api2.pem，原先的获取token接口的证书更改为pta_ptoa.pem，代码改动在`OkHttpUtils.java`**

```java
public static void getAvatarToken(final Callback callback) {
    String url = Constant.web_url_get_token + "&type=" + Constant.netType;
    Log.i(TAG, "getAvatarToken url " + url);
    getInstance().getOkHttpClient().newCall(new Request.Builder().url(url).get().build()).enqueue(new Callback() {
        @Override
        public void onFailure(Call call, IOException e) {
            callback.onFailure(call, e);
        }

        @Override
        public void onResponse(Call call, Response response) throws IOException {
            callback.onResponse(call, response);
        }
    });
}
```



### 库的更新

+ nama.jar
+ p2a_client.jar

+ assets/new/controller.bundle
+ assets/new/controller_config.bundle
+ assets/new/pta_client_q1.bin
+ assets/face_capture.bundle 更新并更名为face_processor_capture.bundle
+ assets/fxaa.bundle
+ assets/pta_client_core.bin
+ jniLibs/各个平台下的libfuai.so、libnama.so、libp2a_client.so



### 头发物理效果优化

#### 资源更新

+ assets/new/hair/所有资源
+ assets/new/head/文件夹下所有资源



### 更新素材

#### 动画

+ assets/new/expression/ani_huxi_hi.bundle
+ assets/new/expression/ani_LRPP_cam.bundle
+ assets/new/expression/ani_hi_mid.bundle
+ assets/new/expression/ani_ok_mid.bundle
+ assets/new/expression/ani_rock_mid.bundle
+ assets/new/expression/ani_dance_cam.bundle
+ assets/new/expression/ani_SZW_cam.bundle
+ assets/new/expression/ani_danshoubixin_mid.bundle

#### 配饰

+ assets/new/decorations/peishi_erding_4.bundle
+ assets/new/decorations/toushi_1.bundle
+ assets/new/decorations/toushi_8.bundle
+ assets/new/decorations/peishi_erding_4.bundle

#### 眉毛

+ assets/new/eyebrow/eyebrow_3.bundle  （其他的都删除）

#### 睫毛

+ assets/new/eyelash/Eyelash_1.bundle

#### 鞋子

+ assets/new/shoes/xiezi_pixie_zhong.bundle

#### 身体

+ assets/new/body/female/midBody_female0.bundle

#### 帽子（删除全部并且更改为发帽素材）

+ assets/new/hat文件夹

**如若发现实际效果与Demo中的不符，请使用Demo中的资源对原有资源进行覆盖更新。**



### sta-tts 升级到最新的版本

#### 更新资源

+ libs/FUTtsEngine.aar



### 模型缩放改为相机bundle控制

#### 新增资源

+ assets/new/camera 文件（相机bundle）

#### 代码逻辑

**定义bundle的路径，代码改动在 `FilePathFactory.java`**

```java
/**
 * 相机bundle 全身
 */
public static final String CAMERA_WHOLE_BODY = "new/camera/cam_35mm_full_80mm_3.bundle";
/**
 * 相机bundle 全身-更小
 */
public static final String CAMERA_SMALL_WHOLE_BODY = "new/camera/change_cam.bundle";
/**
 * 相机bundle 半身
 */
public static final String CAMERA_HALF_LENGTH_BODY = "new/camera/cam_35mm_full_80mm_jinjing.bundle";
/**
 * 相机bundle 半身-更大
 */
public static final String CAMERA_BIG_HALF_LENGTH_BODY = "new/camera/cam_texie.bundle";
```

**加载bundle，代码改动在 `BaseCore.java`**

```java
protected int wholeBodyCameraItem;
protected int smallWholeBodyCameraItem;
protected int halfLengthBodyCameraItem;
protected int bigHalfLengthBodyCameraItem;
protected int currentCameraItem;

/**
 * 相机bundle - 全身
 */
public void loadWholeBodyCamera() {
    if (currentCameraItem != 0 && currentCameraItem == wholeBodyCameraItem) {
        return;
    }
    wholeBodyCameraItem = createAndLoadCameraItem(wholeBodyCameraItem, FilePathFactory.CAMERA_WHOLE_BODY);
}

/**
 * 相机bundle - 全身-更小
 */
public void loadSmallWholeBodyCamera() {
    if (currentCameraItem != 0 && currentCameraItem == smallWholeBodyCameraItem) {
        return;
    }
    smallWholeBodyCameraItem = createAndLoadCameraItem(smallWholeBodyCameraItem, FilePathFactory.CAMERA_SMALL_WHOLE_BODY);

}

/**
 * 相机bundle - 半身
 */
public void loadHalfLengthBodyCamera() {
    if (currentCameraItem != 0 && currentCameraItem == halfLengthBodyCameraItem) {
        return;
    }

    halfLengthBodyCameraItem = createAndLoadCameraItem(halfLengthBodyCameraItem, FilePathFactory.CAMERA_HALF_LENGTH_BODY);
}

/**
 * 相机bundle - 半身-更大
 */
public void loadBigHalfLengthBodyCamera() {
    if (currentCameraItem != 0 && currentCameraItem == bigHalfLengthBodyCameraItem) {
        return;
    }
    bigHalfLengthBodyCameraItem = createAndLoadCameraItem(bigHalfLengthBodyCameraItem, FilePathFactory.CAMERA_BIG_HALF_LENGTH_BODY);
}

protected int createAndLoadCameraItem(int itemId, String bundlePath) {
    return 0;
}
```

**给模型设置默认的镜头、调用相机bundle的时候都需要重置一下模型的位置以及实现 `BaseCore` 中加载相机Bundle的逻辑，代码改动在`PTACore.java`**

```java
 currentCameraItem = mFUItemHandler.loadFUItem(FilePathFactory.CAMERA_WHOLE_BODY);

@Override
public void loadWholeBodyCamera() {
    avatarHandle.resetAllFront();
    super.loadWholeBodyCamera();
}

@Override
public void loadSmallWholeBodyCamera() {
    avatarHandle.resetAllFront();
    super.loadSmallWholeBodyCamera();
}

@Override
public void loadHalfLengthBodyCamera() {
    avatarHandle.resetAllFront();
    super.loadHalfLengthBodyCamera();
}

@Override
public void loadBigHalfLengthBodyCamera() {
    avatarHandle.resetAllFront();
    super.loadBigHalfLengthBodyCamera();
}

@Override
protected int createAndLoadCameraItem(int itemId, String bundlePath) {
    if (itemId == 0) {
        itemId = mFUItemHandler.loadFUItem(bundlePath);
    }
    int finalItemId = itemId;
    queueEvent(new Runnable() {
        @Override
        public void run() {
            faceunity.fuUnBindItems(avatarHandle.controllerItem, new int[]{currentCameraItem});
            faceunity.fuBindItems(avatarHandle.controllerItem, new int[]{currentCameraItem = finalItemId});
        }
    });
    return itemId;
}

@Override
public void release() {
    wholeBodyCameraItem = 0;
    smallWholeBodyCameraItem = 0;
    halfLengthBodyCameraItem = 0;
    bigHalfLengthBodyCameraItem = 0;
    currentCameraItem = 0;
    canResetHomeAnimationPosition = true;
    currentHomeAnimationPosition = -1;
    avatarHandle.release();
    faceunity.fuUnBindItems(avatarHandle.controllerItem, new int[]{controller_config});
    queueEvent(destroyItem(controller_config));

    queueEvent(destroyItem(defaultItem));
    queueEvent(destroyItem(fxaaItem));
    queueEvent(destroyItem(wholeBodyCameraItem));
    queueEvent(destroyItem(smallWholeBodyCameraItem));
    queueEvent(destroyItem(halfLengthBodyCameraItem));
    queueEvent(destroyItem(bigHalfLengthBodyCameraItem));
    queueEvent(destroyFaceCaptureItem(face_capture));
}
```

**去除代码参数对模型位置、大小的控制，改为相机bundle控制，代码改动在 `AvatarHandle.java`**

```java
/**
 * 该方法只做对模型的旋转
 */
public void resetAllFront() {
    mBaseCore.queueEvent(new Runnable() {
        @Override
        public void run() {
            faceunity.fuItemSetParam(controllerItem, "target_angle", 0);
            faceunity.fuItemSetParam(controllerItem, "reset_all", 3);
        }
    });
}

/**
 * 该方法只做对模型的旋转
 */
public void resetAllSide() {
    mBaseCore.queueEvent(new Runnable() {
        @Override
        public void run() {
            faceunity.fuItemSetParam(controllerItem, "target_angle", 0.125);
            faceunity.fuItemSetParam(controllerItem, "reset_all", 3);
        }
    });
}
```

我们可以在不同界面根据业务需求调用不同的相机bundle来对模型的大小、位置进行控制，代码改动分别在 `MainActivity.java` 、`PTACore.java` 、`EditFaceFragment.java` 、`AvatarFragment.java` 页面。



### 界面逻辑修改

主要为UI修改，如果是新增功能的话，会放在 **本次升级所带来新增的内容** 中进行说明。

+ 首次进入APP的时候，人物默认居中显示；（通过相机bundle进行控制）

  > 代码改动在 `MainActivity.java` 中的 `showHomeFragment` 方法中，增加 `mP2ACore.loadWholeBodyCamera();` 。

+ 对捏脸界面进行细分，分别为捏脸界面、美妆界面、服饰界面和场景界面；（主要是UI界面的改动，这里不做赘述，场景切换功能会在**新增的内容**中进行细说）

+ 对合影界面（也叫做表情包页面）进行了修改，默认显示所有的合影相，也可以根据不同的类型进行细分。合影详情页面新增选择背景场景功能。



### 表情包预览界面的宽高修改

**`VideoUtil.java` 修复录屏出现的卡顿、黑屏问题**

```java
public void startRecording(int width, int height, int cropX, int cropY, int textureWidth,
                           int textureHeight, long interval, String input, MediaEncoder.TimeListener timeListener) {
    try {
        stopRecording();
        String videoFileName = DateUtil.getCurrentDate() + "_tmp.mp4";
        mOutFile = new File(Constant.TmpPath, videoFileName);
        if (!mOutFile.getParentFile().exists()) {
            mOutFile.getParentFile().mkdirs();
        }
        mMuxer = new MediaMuxerWrapper(mOutFile.getAbsolutePath());

        // for video capturing
        MediaEncoder mediaVideoEncoder;
        mediaVideoEncoder = new MediaVideoEncoder(mMuxer, mMediaEncoderListener, width, height, cropX, cropY,
                                                  textureWidth, textureHeight);
        mediaVideoEncoder.setInterval(interval);

        MediaEncoder mediaEncoder = null;
        if (!TextUtils.isEmpty(input)) {
            mediaEncoder = new MediaAudioEncoder(mMuxer, mMediaEncoderListener);
            mediaEncoder.setInterval(interval);
            //1 * 1000 * 1000 / 25
            maxNum = 2;
        } else {
            maxNum = 1;
        }
        if (mediaEncoder != null) {
            mediaEncoder.setListener(timeListener);
        }
        //  这边需要sleep 200ms 的问题主要是，我们现在可以任意切换场景，切换场景的时候也需要停止录制再开始录制
        // 由于在停止录制的时候，需要去清除跟释放之前的无用资源，当我们立即开始录制的话，由于之前的资源没有清理完成，
        // mediaEncoder中的录制状态还没有改变成stop，再次开启的话就会出错(状态不对)，所以这边采用睡眠200ms的形式等待stop完成
        // 为什么是200 ms呢？这个是根据多次测试的数据，取得最优值。
        Thread.sleep(200);

        mMuxer.prepare();
        mMuxer.startRecording();
    } catch (final IOException e) {
        Log.e(TAG, "startCapture:", e);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

**`GroupPhotoFragment.java` 设置录制视频的宽高并重构视频录制的调用**

```java
initVideoUtil();

private void initVideoUtil() {
    videoUtil = new VideoUtil(mActivity.getmGLSurfaceView());
    videoUtil.setEndListener(null);
}
// onCreateView
mAvatarLayout.setNextRunnable(new Runnable() {
      @Override
      public void run() {
          if (isAnimationScenes) {
              mActivity.runOnUiThread(new Runnable() {
                  @Override
                  public void run() {
                      Intent intent = new Intent(mActivity, VideoAndImageActivity.class);
                      intent.putExtra("isAnimationScenes", isAnimationScenes);
                      intent.putExtra("path", videoUtil.getOutPath());
                      startActivity(intent);
                  }
              });
          } else {
              mCameraRenderer.takePic(new CameraRenderer.TakePhotoCallBack() {
                  @Override
                  public void takePhotoCallBack(final Bitmap bmp) {
                      mCameraRenderer.setNeedStopDrawFrame(false);
                      mActivity.runOnUiThread(new Runnable() {
                          @Override
                          public void run() {
                              String resultPath = Constant.TmpPath + "tmp.jpg";
                              FileUtil.saveBitmapToFile(resultPath, bmp);

                              Intent intent = new Intent(mActivity, VideoAndImageActivity.class);
                              intent.putExtra("isAnimationScenes", isAnimationScenes);
                              intent.putExtra("path", resultPath);
                              startActivity(intent);
                          }
                      });
                  }
              });
          }
      }
  });


private PTAMultipleCore createPTAMultipleCore() {
  if (mP2AMultipleCore == null) {
      mP2AMultipleCore = new PTAMultipleCore(mActivity, mFUP2ARenderer) {

          @Override
          public int onDrawFrame(byte[] img, int tex, int w, int h, int rotation) {
              int fuTex = super.onDrawFrame(img, tex, w, h, rotation);
              //avatarHandle为空，则生成场景图像
              if (mCurrentAvatarHandler != null) {
                  float nowFrameId = mCurrentAvatarHandler.getAnimateProgress(mCurrentAvatarHandler.expressionItem.handle);
                  if (nowFrameId >= 1.0f) {
                      //录制mp4完成
                      stopRecording();
                      currentFrame = 0;
                      mActivity.runOnUiThread(new Runnable() {
                          @Override
                          public void run() {
                              mAvatarLayout.updateNextBtn(true);
                          }
                      });
                  } else {
                      // 等待3帧再进行录制，防止出现录制到黑屏
                      if (currentFrame > 3) {
                          videoUtil.sendRecordingData(fuTex, GlUtil.IDENTITY_MATRIX);
                      }
                      currentFrame++;
                  }
              }
              return fuTex;
          }
      };
  } else {
      mP2AMultipleCore.updateBg();
  }
  return mP2AMultipleCore;
}

/**
 * 开始录制
 */
private void startRecording() {
    int dimensionPixelSize592 = getResources().getDimensionPixelSize(R.dimen.x592);
    int dimensionPixelSize480 = getResources().getDimensionPixelSize(R.dimen.x480);
    int textureWidth = mCameraRenderer.getCameraHeight();
    int textureHeight = mCameraRenderer.getCameraWidth();

    int viewWidth = dimensionPixelSize480 - (dimensionPixelSize480 % 3);
    int viewHeight = dimensionPixelSize592 - (dimensionPixelSize592 % 3);

    int scale = textureWidth * viewHeight / viewWidth / textureHeight;

    int videoWidth = 0;
    int videoHeight = 0;

    if (scale < 1) {
        //取宽度作为最小值
        videoWidth = Math.min(textureWidth, viewWidth);
        videoHeight = videoWidth * viewHeight / viewWidth;
    } else {
        // 取高度作为最小值
        videoHeight = Math.min(textureHeight, viewHeight);
        videoWidth = videoHeight * viewWidth / viewHeight;
    }

    int cropX = -(textureWidth - videoWidth) / 2;
    int cropY = -(textureHeight - videoHeight) / 2;
    videoUtil.startRecording(videoWidth, videoHeight,
                             cropX, cropY,
                             textureWidth, textureHeight,
                             0, null, null);
}

/**
 * 停止录制
 */
private void stopRecording() {
    videoUtil.stopRecording();
}
```

**`layout_group_photo_show.xml` 预览界面的视频播放高度跟合影界面保持一致**

```xml
<SurfaceView
    android:id="@+id/surfaceview"
    android:layout_width="@dimen/x480"
    android:layout_height="@dimen/x592"
    android:layout_marginTop="@dimen/x238"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent" />
```



### 更新相机动画控制

**`AvatarHandle.java` 更新相机动画控制方法**

```java
/**
 * 相机动画控制
 * <p>
 * start_camera_animation 方法表示开启相机动画
 * pause_camera_animation 方法表示暂停相机动画
 * stop_camera_animation 方法表示停止相机动画并且回到第一帧
 * <p>
 * camera_animation_loop 方法表示相机动画是否需要循环  1表示循环  0 表示不需要循环，也就是播放一遍
 *
 * @param state
 */
public void setCameraAnim(int state) {
    mBaseCore.queueEvent(new Runnable() {
        @Override
        public void run() {
            switch (state) {
                case 1:
                    // 启动当前Camera动画
                    faceunity.fuItemSetParam(controllerItem, "play_camera_animation", 1);
                    break;
                case 2:
                    // 停止当前Camera动画
                    faceunity.fuItemSetParam(controllerItem, "stop_camera_animation", 1);
                    break;
                case 3:
                    // 暂停当前Camera动画
                    faceunity.fuItemSetParam(controllerItem, "pause_camera_animation", 1);
                    break;
                case 4:
                    //重置相机动画，参数无意义，效果相当于先调用stop_camera_animation再调用start_camera_animation
                    faceunity.fuItemSetParam(controllerItem, "reset_camera_animation", 1);
                    break;
            }
        }
    });
}

/**
 * 从头播放句柄为cameraId的相机动画（不循环）
 *
 * @param cameraId
 */
public void setCameraAnimPlayOnce(int cameraId) {
    mBaseCore.queueEvent(new Runnable() {
        @Override
        public void run() {
            faceunity.fuItemSetParam(controllerItem, "play_camera_animation_once", cameraId);
        }
    });
}
```

**`GroupPhotoFragment.java`  调用 `setCameraAnim` 方法对相机动画进行控制并达到预期的效果**

```java
// onAvatarSelectListener 方法
// 停止相机动画
if (mCurrentAvatarHandler != null) {
    mCurrentAvatarHandler.setCameraAnim(3);
}

// backToScenesLayout 方法
// 必须重新设置相机动画为开启状态，要不然就首页设置的相机缩放可能就没有效果了
mAvatarHandleSparse.get(0).setCameraAnim(1);

// startVideoEncoder方法
if (mCurrentAvatar == null) {
    // 借助AvatarHandle对象停止当前的相机动画
    mAvatarHandleSparse.get(0).setCameraAnim(3);
    return;
}
// syncPlayAnim 方法  重置相机的播放状态
mAvatarHandleSparse.get(roleId).setCameraAnim(4);
```



## 本次升级所带来新增的内容

1、<a href="###新增身体驱动" title="身体驱动">新增身体驱动</a>

2、<a href="###增加美妆换色功能" title="增加美妆换色功能">增加美妆换色功能</a>

3、<a href="###增加素材资源" title="增加素材资源">增加素材资源</a>

4、<a href="###捏脸界面增加背景选择功能" title="捏脸界面增加背景选择功能">捏脸界面增加背景选择功能</a>

5、<a href="###表情包自定义背景选择" title="表情包自定义背景选择">表情包自定义背景选择</a>

6、<a href="###新增首页点击触发模型动画" title="新增首页点击触发模型动画">新增首页点击触发模型动画</a>

7、<a href="###增加换装时动画，全身换装时循环播放" title="增加换装时动画">增加换装时动画，全身换装时循环播放</a>

8、<a href="###添加光照bundle" title="添加光照bundle">添加光照bundle</a>

### 新增身体驱动

#### 资源更新

+ human3d.bundle
+ 添加手势文件assets/new/gesture/
+ jniLibs中arm64-v8a和armeabi-v7a平台下的libhexagon_interface.so、libhexagon_nn_skel.so、libhexagon_nn_skel_v65.so、
  libhexagon_nn_skel_v66.so

#### 代码改动部分

**身体驱动逻辑**

**创建身体驱动道具 `PTABodyCore.java`**

```java
human3d = fuP2ARenderer.createHuman3d();

public long createHuman3d() {
      InputStream human3d = null;
      try {
          human3d = mContext.getAssets().open(FilePathFactory.BUNDLE_human3d);
          byte[] human3dDate = new byte[human3d.available()];
          human3d.read(human3dDate);
          human3d.close();
          return faceunity.fu3DBodyTrackerCreate(human3dDate);
      } catch (IOException e) {
          e.printStackTrace();
      }
      return 0;
  }
```

**进入身体驱动模式，代码改动在`AvatarBodyHandle.java`**

```java
//开启身体追踪
public void enterBodyDrive() {
    if (controllerItem > 0) {
        mBaseCore.queueEvent(new Runnable() {
            @Override
            public void run() {
                faceunity.fuItemSetParam(controllerItem, "enter_human_pose_track_mode", 1.0);
            }
        });
    }
}
```

**创建手势道具，代码改动在`AvatarBodyHandle.java`**

```java
private String[] gestures = {
        "new/gesture/anim_fist.bundle",
        "new/gesture/anim_heart.bundle",
        "new/gesture/anim_merge.bundle",
        "new/gesture/anim_one.bundle",
        "new/gesture/anim_palm.bundle",
        "new/gesture/anim_six.bundle",
        "new/gesture/anim_two.bundle",
        "new/gesture/anim_eight.bundle",
        "new/gesture/anim_rock.bundle",
        "new/gesture/anim_thumb.bundle",
        "new/gesture/anim_korheart.bundle",
        "new/gesture/anim_ok.bundle",
        "new/gesture/anim_hold.bundle",
        "new/gesture/anim_gun.bundle",
        "new/gesture/anim_greet.bundle",
};

for (int j = 0; j < gestures.length; j++) {
                if (gestureItem[j] == null) {
                    gestureItem[j] = new FUItem();
                }
                loadItem(gestureItem[j], gestures[j]);
            }
```

**运行身体驱动检测算法，代码改动在`PTABodyCore.java`**

```java
/**
 * human3d:faceunity.fu3DBodyTrackerCreate（human3d.bundle）方法创建的句柄
 * img：输入的图像数据（如相机输入的数据）
 * imgType：输入图像数据的类型（如NV21类型）
 * rotationMode：图像方向（取avatarInfo.mRotationMode的第一个数据）
 */
faceunity.fu3DBodyTrackerRun(human3d, 0, img, w, h, faceunity.FU_FORMAT_NV21_BUFFER, (int) avatarInfo.mRotationMode[0]);

```

**添加全身和半身模式，代码改动在`AvatarBodyHandle.java`**

```java
mAvatarBodyHandle.bodyFullMode(!isChecked, mRecyclerView.getVisibility() == View.VISIBLE);

/**
   * 设置是否开启全身模式
   * 1 全身， 0 半身
   *
   * @param isHalfBodyFull
   */
  public void bodyFullMode(final boolean isHalfBodyFull, boolean bottomViewShowing) {
      if (controllerItem > 0) {
          mBaseCore.queueEvent(new Runnable() {
              @Override
              public void run() {
                  faceunity.fuItemSetParam(controllerItem, "human_3d_track_set_scene", isHalfBodyFull ? 0 : 1);
              }
          });
          if (isHalfBodyFull) {
              if (bottomViewShowing) {
                  resetHalfBodyScreenWithBottomView();
              } else {
                  resetHalfBodyScreenWithoutBottomView();
              }
          } else {
              if (bottomViewShowing) {
                  resetFullBodyScreenWithBottomView();
              } else {
                  resetFullBodyScreenWithoutBottomView();
              }
          }
      }
  }
```


**退出身体驱动页面，退出身体驱动模式，销毁身体驱动道具，代码改动在`AvatarBodyHandle.java`**

```java
//退出面部追踪
1.enterFaceDrive(false);
public void enterFaceDrive(boolean needTrackFace) {
    isNeedTrackFace = needTrackFace;
    avatarBodyHandle.setCNNTrackFace(needTrackFace);
}

/**
 * CNN 面部追踪
 *
 * @param isOpen
 */
public void setCNNTrackFace(boolean isOpen) {
    mBaseCore.queueEvent(new Runnable() {
        @Override
        public void run() {
            //3.设置close_face_capture，说明启用或者关闭CNN面部追踪，value = 0.0表示开启，value = 1.0表示关闭
            faceunity.fuItemSetParam(controllerItem, "close_face_capture", isOpen ? 0.0 : 1.0);
        }
    });
}

//退出身体追踪
2.quitBodyDrive()
public void quitBodyDrive() {
    if (controllerItem > 0) {
        mBaseCore.queueEvent(new Runnable() {
            @Override
            public void run() {
                faceunity.fuItemSetParam(controllerItem, "quit_human_pose_track_mode", 1.0);
            }
        });
    }
}

3.重置全身模式
 mAvatarBodyHandle.bodyFullMode(false, false);

```



### 增加美妆换色功能

增加了对睫毛、眼影、眉毛和唇妆的换色功能

#### 更新或者新增资源

+ assets/new/eyeborw/eyebrow_3.bundle
+ assets/new/eyelash/Eyelash_1.bundle
+ assets/new/makeup/eyeshadow/Eyeshadow_2.bundle (删除)
+ assets/new/makeup/lipgloss/lipgloss_1.bundle

**`BasePTAHandle.java` 获取美妆对应的bundleID并对其设置颜色**

```java
/**
 * 美妆bundle
 */
public int eyebrowHandleId, eyeshadowHandleId, lipglossHandleId,
        eyelashHandleId;
// commitItem方法
setMakeupHandleId();

// setAvatarColor方法
/**
 * 美妆色卡相关
 */
if (eyebrowHandleId > 0) {
    setMakeupColor(eyebrowHandleId, ColorConstant.getMakeupColor(ColorConstant.makeup_color, mAvatarP2A.getEyebrowColorValue()));
}
if (eyeshadowHandleId > 0) {
    setMakeupColor(eyeshadowHandleId, ColorConstant.getMakeupColor(ColorConstant.makeup_color, mAvatarP2A.getEyeshadowColorValue()));
}
if (lipglossHandleId > 0) {
    setMakeupColor(lipglossHandleId, ColorConstant.getMakeupColor(ColorConstant.lip_color, mAvatarP2A.getLipglossColorValue()));
}
if (eyelashHandleId > 0) {
    setMakeupColor(eyelashHandleId, ColorConstant.getMakeupColor(ColorConstant.makeup_color, mAvatarP2A.getEyelashColorValue()));
}

public abstract void setMakeupHandleId();

/**
 * 设置美妆颜色
 *
 * @param color
 */
public void setMakeupColor(int makeupHandleId, double[] color) {
    //设置美妆的颜色
    //美妆参数名为json结构，
    JSONObject jsonObject = new JSONObject();
    try {
        jsonObject.put("name", "global");
        jsonObject.put("type", "face_detail");
        jsonObject.put("param", "blend_color");
        jsonObject.put("UUID", makeupHandleId);//需要修改的美妆道具bundle handle id
    } catch (JSONException e) {
        e.printStackTrace();
    }
    double[] makeupColor = new double[color.length];
    for (int i = 0; i < color.length; i++) {
        makeupColor[i] = color[i] * 1.0 / 255;
    }
    //美妆参数值为0-1之间的RGB设置，美妆颜色原始为RGB色值(sRGB空间)，RGB/255得到传给controller的值
    //例如要替换的美妆颜色为[255,0,0], 传给controller的值为[1,0,0]
    faceunity.fuItemSetParam(controllerItem, jsonObject.toString(), makeupColor);
}
```

**为美妆的bundle ID 进行赋值，代码改动分别在 `AvatarTextDriveHandle.java` 、`AvatarBodyHandle.java` 、`AvatarARDriveHandle.java` 、`AvatarHandle.java`**

```java
@Override
public void setMakeupHandleId() {
    eyebrowHandleId = eyebrowItem.handle;
    eyeshadowHandleId = eyeshadowItem.handle;
    lipglossHandleId = lipglossItem.handle;
    eyelashHandleId = eyelashItem.handle;
}
```

**`EditFaceFragment.java`  添加颜色选择的RecyclerView，并实现点击换色功能**

```java
// showFragment 方法的TITLE_EYEBROW_INDEX、TITLE_EYELASH_INDEX、TITLE_EYESHADOW_INDEX、TITLE_LIPGLOSS_INDEX分支代码修改

// colorValuesChangeListener 方法的TITLE_EYEBROW_INDEX、TITLE_EYELASH_INDEX、TITLE_EYESHADOW_INDEX、TITLE_LIPGLOSS_INDEX分支代码修改

// Revoke 方法的TITLE_EYEBROW_INDEX、TITLE_EYELASH_INDEX、TITLE_EYESHADOW_INDEX、TITLE_LIPGLOSS_INDEX分支代码修改
```

**`AvatarPTA.java` 记录当前模型美妆对应的值**

```java
//美妆相关的色卡值
private double eyebrowColorValue = 0;
private double eyeshadowColorValue = 0;
private double lipglossColorValue = 0;
private double eyelashColorValue = 0;

// AvatarPTA 构造方法，设置默认模型的唇色
if (gender == gender_girl) {
    this.lipglossColorValue = 1;
} else {
    this.lipglossColorValue = 6;
}

public double getEyebrowColorValue() {
    return eyebrowColorValue;
}

public void setEyebrowColorValue(double eyebrowColorValue) {
    this.eyebrowColorValue = eyebrowColorValue;
}

public double getEyeshadowColorValue() {
    return eyeshadowColorValue;
}

public void setEyeshadowColorValue(double eyeshadowColorValue) {
    this.eyeshadowColorValue = eyeshadowColorValue;
}

public double getLipglossColorValue() {
    return lipglossColorValue;
}

public void setLipglossColorValue(double lipglossColorValue) {
    this.lipglossColorValue = lipglossColorValue;
}

public double getEyelashColorValue() {
    return eyelashColorValue;
}

public void setEyelashColorValue(double eyelashColorValue) {
    this.eyelashColorValue = eyelashColorValue;
}

// clone 方法
avatarP2A.eyebrowColorValue = this.eyebrowColorValue;
avatarP2A.eyeshadowColorValue = this.eyeshadowColorValue;
avatarP2A.lipglossColorValue = this.lipglossColorValue;
avatarP2A.eyelashColorValue = this.eyelashColorValue;
// compare方法
avatarP2A.eyebrowColorValue != this.eyebrowColorValue ||
avatarP2A.eyeshadowColorValue != this.eyeshadowColorValue ||
avatarP2A.lipglossColorValue != this.lipglossColorValue ||
avatarP2A.eyelashColorValue != this.eyelashColorValue;
```

**`DBHelper.java` 对美妆颜色进行持久化**

```java
public static final int DATABASE_VERSION = 31;

static final String HISTORY_EYEBROW_COLOR = "eyebrow_color_values";
static final String HISTORY_LIPGLOSS_COLOR = "lipgloss_color_values";
static final String HISTORY_EYELASH_COLOR = "eyelash_color_values";
static final String HISTORY_EYESHADOW_COLOR = "eyeshadow_color_values";

//  onCreate方法
" lipgloss_color_values double," +
" eyelash_color_values double," +
" eyebrow_color_values double," +
" eyeshadow_color_values double," +

// insertHistory 方法
contentValues.put(HISTORY_LIPGLOSS_COLOR, avatarP2A.getLipglossColorValue());
contentValues.put(HISTORY_EYELASH_COLOR, avatarP2A.getEyelashColorValue());
contentValues.put(HISTORY_EYEBROW_COLOR, avatarP2A.getEyebrowColorValue());
contentValues.put(HISTORY_EYESHADOW_COLOR, avatarP2A.getEyeshadowColorValue());
// updateHistory 方法
contentValues.put(HISTORY_LIPGLOSS_COLOR, avatarP2A.getLipglossColorValue());
contentValues.put(HISTORY_EYELASH_COLOR, avatarP2A.getEyelashColorValue());
contentValues.put(HISTORY_EYEBROW_COLOR, avatarP2A.getEyebrowColorValue());
contentValues.put(HISTORY_EYESHADOW_COLOR, avatarP2A.getEyeshadowColorValue());

// getAllHistoryItems方法
int lipglossColorIndex = res.getColumnIndex(HISTORY_LIPGLOSS_COLOR);
int eyelashColorIndex = res.getColumnIndex(HISTORY_EYELASH_COLOR);
int eyebrowColorIndex = res.getColumnIndex(HISTORY_EYEBROW_COLOR);
int eyeshadowColorIndex = res.getColumnIndex(HISTORY_EYESHADOW_COLOR);

historyItem.setLipglossColorValue(res.getDouble(lipglossColorIndex));
historyItem.setEyelashColorValue(res.getDouble(eyelashColorIndex));
historyItem.setEyebrowColorValue(res.getDouble(eyebrowColorIndex));
historyItem.setEyeshadowColorValue(res.getDouble(eyeshadowColorIndex));
```



### 增加素材资源

#### 美瞳

+ assets/new/makeup/pupil/pupil_3.bundle

#### 衣服

+ assets/new/clothes/taozhuang_10.bundle
+ assets/new/clothes/taozhuang_11.bundle
+ assets/new/clothes/taozhuang_12.bundle
+ assets/new/clothes/taozhuang_13.bundle
+ assets/new/clothes/taozhuang_14.bundle
+ assets/new/clothes/taozhuang_15.bundle

#### 鞋子

+ assets/new/shoes/xiezi_pixie_gaogen.bundle

### 动画

+ assets/new/expression/ani_change_01.bundle

  

### 捏脸界面增加背景选择功能

#### 新增资源

+ assets/new/scenes/2d 文件夹

#### 代码逻辑改动

针对捏脸界面，我们对捏脸界面用到的静态属性进行了统一的管理，捏脸项的添加进行统一管理，代码在 `EditFaceItemManager.java` 中

**`FilePathFactory.java` 定义了对应bundle的地址、设置预制模型的背景**

```java
/**
* head：预置模型
*/
public static List<AvatarPTA> getDefaultAvatarP2As() {
  List<AvatarPTA> p2AS = new ArrayList<>();
  p2AS.add(0, new AvatarPTA("new/head/head_1/", R.drawable.head_1_male, AvatarPTA.gender_boy,
                            "new/head/head_1/head.bundle", 7, 0,
                            0, 1, 1, 1,
                            0, 1));
  p2AS.add(1, new AvatarPTA("new/head/head_2/", R.drawable.head_2_female, AvatarPTA.gender_girl,
                            "new/head/head_2/head.bundle", 25, 0,
                            0, 5, 1, 1,
                            0, 1));
  return p2AS;
}

/**
 * 2D场景背景
 */
private static final BundleRes[] SCENES_2D = {
        new BundleRes(AvatarPTA.gender_mid, FilePathFactory.BUNDLE_default_bg, R.drawable.edit_face_item_none),
        new BundleRes(AvatarPTA.gender_mid, "new/expression/scenes/2d/keting_A_mesh.bundle", R.drawable.keting_a),
        new BundleRes(AvatarPTA.gender_mid, "new/expression/scenes/2d/keting_mesh.bundle", R.drawable.keting_b),
        new BundleRes(AvatarPTA.gender_mid, "new/expression/scenes/2d/wuguan_mesh.bundle", R.drawable.wuguan),
        new BundleRes(AvatarPTA.gender_mid, "new/expression/scenes/2d/yuanlin_mesh.bundle", R.drawable.yuanlin),

};

public static List<BundleRes> scenes2DBundleRes() {
    return Arrays.asList(SCENES_2D);
}

/**
 * 3D场景背景
 */
private static final BundleRes[] SCENES_3D = {
//            new BundleRes(AvatarPTA.gender_mid, "", R.drawable.edit_face_reset)
};

public static List<BundleRes> scenes3dBundleRes() {
    return Arrays.asList(SCENES_3D);
}

/**
 * 动画背景
 */
private static final BundleRes[] SCENES_ANI = {
//            new BundleRes(AvatarPTA.gender_mid, "", R.drawable.edit_face_reset)
};

public static List<BundleRes> scenesAniBundleRes() {
    return Arrays.asList(SCENES_ANI);
}
```

**`EditFaceFragment.java` 添加背景的切换逻辑**

```java
// showFragment 方法的TITLE_SCENES_2D、TITLE_SCENES_3D、TITLE_SCENES_ANIMATION分支代码新增

// itemChangeListener 方法的TITLE_SCENES_2D、TITLE_SCENES_3D、TITLE_SCENES_ANIMATION分支代码新增

// Revoke 方法的TITLE_SCENES_2D、TITLE_SCENES_3D、TITLE_SCENES_ANIMATION分支代码新增
```

**`AvatarPTA.java` 增加对应背景的属性**

```java
// 背景
private int background2DIndex = -1;
private int background3DIndex = -1;
private int backgroundAniIndex = -1;

// AvatarPTA方法
background2DIndex = -1;
background3DIndex = -1;
backgroundAniIndex = -1;
// AvatarPTA方法  接收预制模型的背景
this.background2DIndex = background2DIndex;

public int getBackground2DIndex() {
    return background2DIndex;
}

public void setBackground2DIndex(int background2DIndex) {
    this.background2DIndex = background2DIndex;
}

public int getBackground3DIndex() {
    return background3DIndex;
}

public void setBackground3DIndex(int background3DIndex) {
    this.background3DIndex = background3DIndex;
}

public int getBackgroundAniIndex() {
    return backgroundAniIndex;
}

public void setBackgroundAniIndex(int backgroundAniIndex) {
    this.backgroundAniIndex = backgroundAniIndex;
}

public String getBackgroundFile() {
    if (background2DIndex > 0) {
        return getStringByIndex(FilePathFactory.scenes2DBundleRes(), background2DIndex);
    }
    if (background3DIndex > 0) {
        return getStringByIndex(FilePathFactory.scenes3dBundleRes(), background3DIndex);
    }
    if (backgroundAniIndex > 0) {
        return getStringByIndex(FilePathFactory.scenesAniBundleRes(), backgroundAniIndex);
    }
    return FilePathFactory.BUNDLE_default_bg;
}
// clone()
avatarP2A.background2DIndex = this.background2DIndex;
avatarP2A.background3DIndex = this.background3DIndex;
avatarP2A.backgroundAniIndex = this.backgroundAniIndex;

// compare()
avatarP2A.background2DIndex != this.background2DIndex ||
avatarP2A.background3DIndex != this.background3DIndex ||
avatarP2A.backgroundAniIndex != this.backgroundAniIndex ||
```

**`DBHelper.java` 持久化数据**

```java
static final String HISTORY_BACKGROUND_2D_INDEX = "background_2d_index";
static final String HISTORY_BACKGROUND_3D_INDEX = "background_3d_index";
static final String HISTORY_BACKGROUND_ANI_INDEX = "background_ani_index";
// onCreate 方法
" background_2d_index integer," +
" background_3d_index integer," +
" background_ani_index integer" +

// insertHistory 方法
contentValues.put(HISTORY_BACKGROUND_2D_INDEX, avatarP2A.getBackground2DIndex());
contentValues.put(HISTORY_BACKGROUND_3D_INDEX, avatarP2A.getBackground3DIndex());
contentValues.put(HISTORY_BACKGROUND_ANI_INDEX, avatarP2A.getBackgroundAniIndex());
// updateHistory 方法
contentValues.put(HISTORY_BACKGROUND_2D_INDEX, avatarP2A.getBackground2DIndex());
contentValues.put(HISTORY_BACKGROUND_3D_INDEX, avatarP2A.getBackground3DIndex());
contentValues.put(HISTORY_BACKGROUND_ANI_INDEX, avatarP2A.getBackgroundAniIndex());
// getAllHistoryItems 方法
int background2DIndex = res.getColumnIndex(HISTORY_BACKGROUND_2D_INDEX);
int background3DIndex = res.getColumnIndex(HISTORY_BACKGROUND_3D_INDEX);
int backgroundAniIndex = res.getColumnIndex(HISTORY_BACKGROUND_ANI_INDEX);

historyItem.setBackground2DIndex(res.getInt(background2DIndex));
historyItem.setBackground3DIndex(res.getInt(background3DIndex));
historyItem.setBackgroundAniIndex(res.getInt(backgroundAniIndex));
```

### 表情包自定义背景选择

表情包自定义背景主要代码在 `com.faceunity.pta_art.fragment.groupavatar` 文件夹下，主要的是UI上的改的。

**`GroupPhotoFragment.java` 加载选择的背景**

```java
mAvatarLayout.setBgBundleChangeListener(new GroupPhotoScenesFragment.OnBgBundleChangeListener() {
    @Override
    public void onBgBundleChangeListener(String path) {
        mP2AMultipleCore.loadBundleBg(path);
        if (isAnimationScenes) {
            startVideoEncoder();
        }
    }
});
```

**`PTAMultipleCore.java` 加载背景bundle**

```java
public int fxaaItem, defaultBgItem, currentBgItem;

public PTAMultipleCore(Context context, FUPTARenderer fuP2ARenderer) {
    super(context, fuP2ARenderer);
    defaultBgItem = mFUItemHandler.loadFUItem(FilePathFactory.BUNDLE_default_bg);
    bgItems[0] = currentBgItem = defaultBgItem;
    mItemsArray[ITEM_ARRAYS_FXAA] = fxaaItem = mFUItemHandler.loadFUItem(FilePathFactory.BUNDLE_fxaa);
}

public void updateBg() {
    defaultBgItem = mFUItemHandler.loadFUItem(FilePathFactory.BUNDLE_default_bg);
    bgItems[0] = currentBgItem = defaultBgItem;
}

// release()
queueEvent(destroyItem(currentBgItem));

public void loadBundleBg(String bgPath) {
    int fuItem = mFUItemHandler.loadFUItem(bgPath);
    queueEvent(new Runnable() {
        @Override
        public void run() {
            faceunity.fuUnBindItems(controllerItem, bgItems);
            faceunity.fuDestroyItem(currentBgItem);
            bgItems[0] = currentBgItem = fuItem;
            faceunity.fuBindItems(controllerItem, bgItems);
            mBackgroundUtil.setUseBitmapBackground(false);
        }
    });
}
```

我们除了可以给表情包选择背景以外，还支持了设置默认背景，代码改动如下：

**`assets/new/expression/expression_config.json` 中添加 `bg_2d` 属性用于指定默认背景的位置**

```json
{
  "icon": "new_expression_single_2",
  "camera": "new/expression/ani_LRPP_cam.bundle",
  "bg_2d": 4,
  "BundleRes": [
    {
      "gender": 1,
      "path": "new/expression/ani_LRPP_mid.bundle",
      "others": [
        "new/expression/LRPP_shanzi.bundle",
        "new/expression/ani_LRPP_shanzi.bundle"
      ]
    }
  ]
}
```

**`JsonUtils.java`  增加对JSON新增字段的解析**

```java
private void resolveExpressionJson(JSONObject jsonObject, boolean isAnimate) {
    int resId = 0;//icon
    List<BundleRes> resList = new ArrayList<>();
    resId = context.getResources().getIdentifier((String) jsonObject.opt("icon"), "drawable", context.getPackageName());
    String camera = jsonObject.optString("camera");//相机位置
    int bg2d = jsonObject.optInt("bg_2d", 0);//2d相机背景
    int bg3d = jsonObject.optInt("bg_3d", 0);//3d相机背景
    int bgAni = jsonObject.optInt("bg_ani", 0);//动画相机背景
    Scenes.ScenesBg scenesBg = new Scenes.ScenesBg(bg2d, bg3d, bgAni);
    JSONArray jsonArray = (JSONArray) (jsonObject.opt("BundleRes"));
    String path = "";
    int gender = 0;
    String[] jsonStr = null;
    for (int m = 0; m < jsonArray.length(); m++) {
        try {
            JSONObject object = jsonArray.getJSONObject(m);
            Iterator iterator1 = object.keys();
            while (iterator1.hasNext()) {
                String key1 = iterator1.next().toString();
                Object value1 = object.opt(key1);
                if (value1 instanceof Integer) {
                    gender = (int) value1;
                } else if (value1 instanceof String) {
                    path = (String) value1;
                } else if (value1 instanceof JSONArray) {
                    if (((JSONArray) (value1)).length() > 0) {
                        JSONArray tempArray = (JSONArray) (value1);
                        jsonStr = tempArray.length() > 0 ? new String[tempArray.length()] : new String[]{};
                        for (int l = 0; l < tempArray.length(); l++) {
                            jsonStr[l] = tempArray.getString(l);
                        }
                    }
                }
            }
            if (jsonStr == null || jsonStr.length <= 0) {
                resList.add(new BundleRes(gender, path));
            } else {
                resList.add(new BundleRes(gender, path, jsonStr));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
    BundleRes[] bundleRes = new BundleRes[resList.size()];
    resList.toArray(bundleRes);
    scenesList.add(new Scenes(resId, bundleRes, scenesBg, camera, isAnimate));
}
```

**`Scenes.java`  新增对背景属性**

```java
public static class ScenesBg {
    public int bg_2d;
    public int bg_3d;
    public int bg_ani;

    public ScenesBg(int bg_2d, int bg_3d, int bg_ani) {
        this.bg_2d = bg_2d;
        this.bg_3d = bg_3d;
        this.bg_ani = bg_ani;
    }

    public ScenesBg clone() {
        return new ScenesBg(this.bg_2d, this.bg_3d, this.bg_ani);
    }

}
```

### 新增首页点击触发模型动画

**`AvatarHandle.java` 添加设置动画的方法**

```java
// setAvatar 方法，对该方法进行重构，将动画设置到Avatar中并进行触发
loadItem(expressionItem, loadExpressionBundle(avatar));

private String loadExpressionBundle(AvatarPTA avatar) {
    String bundlePath = null;
    if (TextUtils.isEmpty(avatar.getExpressionFile())) {
        if (isPose) {
            bundlePath = FilePathFactory.bundlePose(avatar.getGender());
        } else if (mIsNeedTrack || mIsNeedFacePUP || mIsNeedIdle) {
            bundlePath = FilePathFactory.bundleIdle(avatar.getGender());
        } else {
            bundlePath = FilePathFactory.bundleAnim(avatar.getGender());
        }
    } else {
        bundlePath = avatar.getExpressionFile();
    }
    return bundlePath;
}


/**
 * 设置模型动画
 *
 * @param mShowAvatarP2A
 * @param bundleRes
 */
public void setExpression(AvatarPTA mShowAvatarP2A, BundleRes bundleRes, int loadCount) {
    setExpression(mShowAvatarP2A, bundleRes, true, loadCount);
}

/**
 * 设置模型动画
 *
 * @param mShowAvatarP2A
 * @param bundleRes
 */
public void setExpression(AvatarPTA mShowAvatarP2A, BundleRes bundleRes, boolean needResetAvatar, int loadCount) {
    mShowAvatarP2A.setExpression(bundleRes);
    setCurrentAniLoadCount(loadCount);
    needResetAvatar(mShowAvatarP2A, needResetAvatar);
}


/**
 * 取消模型动画
 *
 * @param mShowAvatarP2A
 */
public void clearExpression(AvatarPTA mShowAvatarP2A, boolean needResetAvatar) {
    if (!TextUtils.isEmpty(mShowAvatarP2A.getExpressionFile())) {
        setCurrentAniLoadCount(Integer.MAX_VALUE);
        mShowAvatarP2A.setExpression(new BundleRes(""));
        needResetAvatar(mShowAvatarP2A, needResetAvatar);
    }
}

private void needResetAvatar(AvatarPTA mShowAvatarP2A, boolean needResetAvatar) {
    if (needResetAvatar) {
        setAvatar(mShowAvatarP2A);
    }
}

public void setCurrentAniLoadCount(int loadCount) {
    this.loadCount = loadCount;
}

public int getLoadCount() {
    return loadCount;
}

private int loadCount = Integer.MAX_VALUE;
```

**`FilePathFactory.java` 配置首页切换的动画列表**

```java
/**
 * EXPRESSION：首页切换动画
 */
private static final String EXPRESSION_NIE_ROCK = "new/expression/ani_rock_mid.bundle";
private static final String EXPRESSION_NIE_HI = "new/expression/ani_hi_mid.bundle";
private static final String EXPRESSION_NIE_DANSHOUBIXIN = "new/expression/ani_danshoubixin_mid.bundle";

public static List<String> getHomeSwitchAnimation() {
    ArrayList<String> arrayList = new ArrayList<>();
    arrayList.add(EXPRESSION_NIE_ROCK);
    arrayList.add(EXPRESSION_NIE_HI);
    arrayList.add(EXPRESSION_NIE_DANSHOUBIXIN);
    return arrayList;
}
```

**`PTACore.java` 监听动画的进度以及回调各种监听事件**

```java
int loadCount = avatarHandle.getLoadCount();
    if (loadCount != Integer.MAX_VALUE) {
        if (avatarHandle.expressionItem.handle > 0) {
            float progress = avatarHandle.getAnimateProgress(avatarHandle.expressionItem.handle);
            if (loadCount - progress < 0.05 && loadCount - progress > 0) {
                // progress并不是一个整型，我们这里取一个范围，也就是loadCount± 0.05 就算是播放完毕

                if (aniLoadCompletedListener != null && (mFrameId - lastLoadCompletedFrameId > 1)) {
                    // (mFrameId - lastLoadCompletedFrameId > 1) 表示上次结束动画在上一帧，这一帧又结束一个新动画，
                    // 这显然是不合理的，所以做过滤
                    aniLoadCompletedListener.loadCompleted(Math.round(progress), currentHomeAnimationPosition, !canResetHomeAnimationPosition);
                    canResetHomeAnimationPosition = true;
                    lastLoadCompletedFrameId = mFrameId;
                }
            }
        }
    }

public interface AniLoadCompletedListener {
    /**
     * 当前的动画已经播放了一遍，也可能是多遍，主要根据loadCount来判断
     *
     * @param loadCount             当前动画播放了多少遍
     * @param nextAnimationPosition 需要播放的下一个动画所在FilePathFactory.getHomeSwitchAnimation()集合中的位置
     * @param haveNextAni           是否有下一个动画，如果没有下一个动画，nextAnimationPosition的值为当前动画
     *                              所在FilePathFactory.getHomeSwitchAnimation()集合中的位置
     */
    void loadCompleted(int loadCount, int nextAnimationPosition, boolean haveNextAni);
}

private AniLoadCompletedListener aniLoadCompletedListener;

public void setAniLoadCompletedListener(AniLoadCompletedListener aniLoadCompletedListener) {
    this.aniLoadCompletedListener = aniLoadCompletedListener;
}

public interface AniRefreshNowListener {
    /**
     * 动画需要立即播放
     *
     * @param currentHomeAnimationPosition 动画所在FilePathFactory.getHomeSwitchAnimation()集合中的位置
     */
    void refreshNow(int currentHomeAnimationPosition);
}

private AniRefreshNowListener aniRefreshNowListener;

public void setAniRefreshNowListener(AniRefreshNowListener aniRefreshNowListener) {
    this.aniRefreshNowListener = aniRefreshNowListener;
}

public void setNextHomeAnimationPosition() {
    int size = FilePathFactory.getHomeSwitchAnimation().size();
    if (size == 0) {
        return;
    }
    if (canResetHomeAnimationPosition) {
        currentHomeAnimationPosition = ++currentHomeAnimationPosition % size;
        if (size == 1) {
            // 如果只有一个动画，则需要改动avatarHandle中的loadCount，否则会导致动画的异常结束
            // 因为我们是通过loadCount - progress 去判断动画是否执行完毕，如果重复的执行同一个动画，
            // progress是不会重置为0 的，所以我们需要增加loadCount
            avatarHandle.setCurrentAniLoadCount(avatarHandle.getLoadCount() + 1);
        }
        canResetHomeAnimationPosition = false;
    }
    if (avatarHandle.getLoadCount() == Integer.MAX_VALUE) {
        // 当前为idle动画，可以立即刷新动画
        if (aniRefreshNowListener != null) {
            aniRefreshNowListener.refreshNow(currentHomeAnimationPosition);
            canResetHomeAnimationPosition = true;
        }
    }
}
````

**`MainActivity.java` 设置关于动画的结束以及开启新动画的监听**

```java
mP2ACore.setAniLoadCompletedListener(listener);

    mP2ACore.setAniRefreshNowListener(new PTACore.AniRefreshNowListener() {
        @Override
        public void refreshNow(int currentHomeAnimationPosition) {
            listener.loadCompleted(0, currentHomeAnimationPosition, true);
        }
    });

private PTACore.AniLoadCompletedListener listener = new PTACore.AniLoadCompletedListener() {
    @Override
    public void loadCompleted(int loadCount, int nextAnimationPosition, boolean haveNextAni) {
        if (haveNextAni) {
            List<String> homeSwitchAnimation = FilePathFactory.getHomeSwitchAnimation();
            if (nextAnimationPosition >= homeSwitchAnimation.size()) {
                return;
            }
            mAvatarHandle.setExpression(mShowAvatarP2A, new BundleRes(homeSwitchAnimation.get(nextAnimationPosition)), 1);
        } else {
            mAvatarHandle.clearExpression(mShowAvatarP2A, true);
        }
    }
};
```

**`HomeFragment.java` 对界面点击事件的监听**

```java
@Override
public boolean onSingleTapUp(MotionEvent e) {
    mP2ACore.setNextHomeAnimationPosition();
    return super.onSingleTapUp(e);
}
```

### 增加换装时动画，全身换装时循环播放

**`EditFaceFragment.java` 增加换装时动画，其他场景不需要**

```java
if (id == -1) {
    mP2ACore.loadWholeBodyCamera();
} else if (id == TITLE_CLOTHES_INDEX
        || id == TITLE_CLOTHES_UPPER_INDEX
        || id == TITLE_CLOTHES_LOWER_INDEX
        || id == TITLE_SHOE_INDEX
        || id == TITLE_DECORATIONS_INDEX) {
    mAvatarHandle.setExpression(mAvatarP2A, new BundleRes(FilePathFactory.EXPRESSION_ANI_DRESS_UP), Integer.MAX_VALUE);
    mP2ACore.loadSmallWholeBodyCamera();

} else if (id == TITLE_SCENES_2D
        || id == TITLE_SCENES_3D
        || id == TITLE_SCENES_ANIMATION) {
    mAvatarHandle.clearExpression(mAvatarP2A, true);
    mP2ACore.loadSmallWholeBodyCamera();
} else {
    mAvatarHandle.clearExpression(mAvatarP2A, true);
    mP2ACore.loadHalfLengthBodyCamera();
}
// backToHome 清除动画
mAvatarHandle.clearExpression(avatarP2A, false);
```

### 添加光照bundle

#### 新增资源

+ assets/new/light/light_0.6.bundle

#### 加载光照

`FilePathFactory.java`

```java
/**
 * 光照
 */
public static final String BUNDLE_light = "new/light/light_0.6.bundle";
```

**`AvatarHandle.java` 添加光照开启关闭的方法**

```java
/**
 * 光照
 */
private int lightItem;

/**
 * 开启光照
 */
public void openLight(String lightPath) {
    if (controllerItem > 0) {
        closeLight();
        mBaseCore.queueEvent(new Runnable() {
            @Override
            public void run() {
                lightItem = mFUItemHandler.loadFUItem(lightPath);
                if (lightItem > 0) {
                    faceunity.fuBindItems(controllerItem, new int[]{lightItem});
                }
            }
        });
    }
}

/**
 * 关闭光照
 */
public void closeLight() {
    if (controllerItem > 0) {
        mBaseCore.queueEvent(new Runnable() {
            @Override
            public void run() {
                if (lightItem > 0) {
                    faceunity.fuUnBindItems(controllerItem, new int[]{lightItem});
                    faceunity.fuDestroyItem(lightItem);
                    lightItem = 0;
                }
            }
        });
    }
}

// releaseAll方法
if (isControllerRelease) {
    controllerItem = 0;
    closeLight();
}
```

**`MainActivity.java` 开启灯光，全局只需要开启一次**

```java
mAvatarHandle.setAvatar(getShowAvatarP2A(), new Runnable() {
    @Override
    public void run() {
        mAvatarHandle.openLight(FilePathFactory.BUNDLE_light);
        mHomeFragment.checkGuide();
    }
});
```



## 本次升级所修复的内容

1、<a href="###修复内存泄露" title="修复内存泄露">修复内存泄露</a>

### 修复内存泄露

+ 修复重复创建face_pature导致的内存泄露；
+ 修复没有正常销毁道具导致的内存泄露；
+ 修复捏脸保存的时候，由底层库带来的内存泄露；
+ 修复调用底层方法销毁道具不完全导致的内存泄露；
+ 修复内部类持有外部类引用导致的内存泄露；
+ 修复DialogFragment引起的内存泄露；

由于底层库的原因导致的内存泄露需要更新底层库，之前在更新内容中已经包含了需要更新的库，所以就不列出来了。

#### 修复重复创建face_pature导致的内存泄露

**`PTACore.java` 单个参数的构造函数中不需要再次调用 `face_capture = mFUP2ARenderer.createFaceCapture();` 方法**

```
public PTACore(PTACore core) {
    super(core.mContext, core.mFUP2ARenderer);
    avatarHandle = core.avatarHandle;
    System.arraycopy(core.mItemsArray, 0, mItemsArray, 0, ITEM_ARRAYS_COUNT);
    fxaaItem = core.fxaaItem;
    face_capture = core.face_capture;
    currentCameraItem = mFUItemHandler.loadFUItem(FilePathFactory.CAMERA_WHOLE_BODY);
}
```

#### 修复没有正常销毁道具导致的内存泄露

`MainActivity.java`

```java
@Override
public int onDrawFrame(byte[] cameraNV21Byte, int cameraTextureId, int cameraWidth, int cameraHeight, int rotation) {
    if (isClose) {
        closeNum--;
        if (closeNum <= 0) {
            destroyCount.countDown();
        }
    } else {
        mCameraRenderer.refreshLandmarks(mP2ACore.getLandmarksData());
    }
    int fuTextureId = mFUP2ARenderer.onDrawFrame(cameraNV21Byte, cameraTextureId, cameraWidth, cameraHeight, rotation);
    return fuTextureId;
}

@Override
public void onBackPressed() {
    if (mBaseFragment != null) {
        if (!isCanClick) {
            ToastUtil.showCenterToast(MainActivity.this, "模型载入中，请稍后...");
            return;
        }
        mBaseFragment.onBackPressed();
        return;
    }

    FilePathFactory.clearCache();
    ColorConstant.release();

    if (FUApplication.needRestartMainActivity) {
        FUPTAClient.isCoreInit = false;
        FUPTAClient.isStyleInit = false;
        onFinish();
    } else {
        finish();
        android.os.Process.killProcess(android.os.Process.myPid());
        Runtime.getRuntime().gc();
    }
}

private volatile boolean isClose = false;
private volatile int closeNum = 5;
private CountDownLatch destroyCount;

public void onFinish() {
    if (mCameraRenderer != null) {
        mCameraRenderer.setNeedStopDrawToScreen(true);
    }
    mP2ACore.queueNextEvent(new Runnable() {
        @Override
        public void run() {
            closeNum = 5;
            isClose = true;
            mP2ACore.release();
            mP2ACore.face_capture = 0;
        }
    });
    destroyCount = new CountDownLatch(1);
    try {
        destroyCount.await(1, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    finish();
}
```

**在 `FUPTARenderer.java` 中底层中所占用的内存进行了释放**

```java 
public void onSurfaceDestroyed() {
    mFUCore.unBind();
    mFUCore.release();
    fuPTAClient.fuPTAReleaseData();
    faceunity.fuDestroyAllItems();
    faceunity.fuOnDeviceLost();
    faceunity.fuDone();
    release();
}
```

`CameraRender.java`

```java
private boolean isNeedStopDrawToScreen = false;

private float[] mLastMvp;
private FBOUtils fboUtils;
private int fboTextureId;

public void setNeedStopDrawToScreen(boolean needStopDrawToScreen) {
    mGLSurfaceView.queueEvent(new Runnable() {
        @Override
        public void run() {
            if (needStopDrawToScreen) {
                mLastMvp = mvp;
                fboUtils = new FBOUtils();
                fboUtils.init();
                fboTextureId = fboUtils.drawFBO(mFuTextureId, mCameraHeight, mCameraWidth, 0);
            }
            isNeedStopDrawToScreen = needStopDrawToScreen;
        }
    });
}

// drawToScreen() 方法绘制上一帧的数据
if (isNeedStopDrawToScreen) {
    // 绘制上一帧的数据
    mFullFrameRectTexture2D.drawFrame(fboTextureId, GlUtil.IDENTITY_MATRIX, mLastMvp);
    return;
}

// onSurfaceDestroy方法
if (fboUtils != null) {
  fboUtils.deleteFBO();
  fboUtils = null;
}

public void onDestroy() {
  final CountDownLatch count = new CountDownLatch(1);
  mGLSurfaceView.queueEvent(new Runnable() {
      @Override
      public void run() {
          onSurfaceDestroy();
          count.countDown();
      }
  });
  try {
      count.await(1, TimeUnit.SECONDS);
  } catch (InterruptedException e) {
      e.printStackTrace();
  }
  mGLSurfaceView.onPause();
  mActivity = null;
}
```

**`FUPTARenderer.java`   `mFUCore.face_capture` 被回收以后就不做数据分析了**

```java
private void prepareDrawFrame() {
    //计算FPS等数据
    benchmarkFPS();
    if (mFUCore.face_capture > 0) {
        //获取人脸是否识别，并调用回调接口
        int isTracking = mFUCore.isTracking();
        if (mOnTrackingStatusChangedListener != null && mTrackingStatus != isTracking) {
            mOnTrackingStatusChangedListener.onTrackingStatusChanged(mTrackingStatus = isTracking);
        }

        //获取faceunity错误信息，并调用回调接口
        int error = faceunity.fuGetSystemError();
        if (error != 0)
            Log.e(TAG, "fuGetSystemErrorString " + faceunity.fuGetSystemErrorString(error));
        if (mOnSystemErrorListener != null && error != 0) {
            mOnSystemErrorListener.onSystemError(error == 0 ? "" : faceunity.fuGetSystemErrorString(error));
        }

        //获取是否正在表情校准，并调用回调接口
        final float[] isCalibratingTmp = new float[1];
        faceunity.fuGetFaceInfo(0, "is_calibrating", isCalibratingTmp);
        if (mOnCalibratingListener != null && isCalibratingTmp[0] != mIsCalibrating) {
            mOnCalibratingListener.OnCalibrating(mIsCalibrating = isCalibratingTmp[0]);
        }
    }
    //queueEvent的Runnable在此处被调用
    while (mEventQueue != null && !mEventQueue.isEmpty()) {
        Runnable r = mEventQueue.remove(0);
        if (r != null)
            r.run();
    }
    mEventQueue.addAll(mNextEventQueue);
    mNextEventQueue.clear();
}
```

#### 将Demo中使用到的静态对象在页面销毁的时候都置空

`ColorConstant.java`

```java
public static void release() {
    skin_color = null;
    lip_color = null;
    iris_color = null;
    hair_color = null;
    beard_color = null;
    glass_frame_color = null;
    glass_color = null;
    hat_color = null;
}
```

`FilePathFactory.java`

```java
public static void clearCache() {
    cacheMap.clear();
}
```

`VideoUtil.java`

```java
public void release() {
    mGlSurfaceView = null;
}
```

**在 `MainActivity.java` 的 `onBackPressed` 方法中进行资源释放，方法上面已经有了，不再赘述**

`EditFaceParameter.java`

```java
public void release() {
    HeadBone_stretch = "";
    HeadBone_shrink = "";
    HeadBone_wide = "";
    HeadBone_narrow = "";
    Head_wide = "";
    Head_narrow = "";
    head_shrink = "";
    head_stretch = "";
    if (mMap != null) {
        mMap.clear();
    }
    if (mDefaultMap != null) {
        mDefaultMap.clear();
    }
    if (tempMap != null) {
        tempMap.clear();
    }
    if (mLastMap != null) {
        mLastMap.clear();
    }
}
```

`EditFacePointFactory.java`

```java
public static void release() {

    mMaleFaceFrontPoints = null;
    mMaleFaceSidePoints = null;
    mMaleEyeFrontPoints = null;
    mMaleEyeSidePoints = null;
    mMaleMouthFrontPoints = null;
    mMaleMouthSidePoints = null;
    mMaleNoseFrontPoints = null;
    mMaleNoseSidePoints = null;

    mFemaleFaceFrontPoints = null;
    mFemaleFaceSidePoints = null;
    mFemaleEyeFrontPoints = null;
    mFemaleEyeSidePoints = null;
    mFemaleMouthFrontPoints = null;
    mFemaleMouthSidePoints = null;
    mFemaleNoseFrontPoints = null;
    mFemaleNoseSidePoints = null;

    mMidFaceFrontPoints = null;
    mMidFaceSidePoints = null;
    mMidEyeFrontPoints = null;
    mMidEyeSidePoints = null;
    mMidMouthFrontPoints = null;
    mMidMouthSidePoints = null;
    mMidNoseFrontPoints = null;
    mMidNoseSidePoints = null;
}
```

`EditParamFactory.java`

```java
public static void release() {
    mEditParamFace = null;
    mEditParamMouth = null;
    mEditParamEye = null;
    mEditParamNose = null;
}
```

`Drawable2d.java`

```java
public void release() {
    if (mTexCoordArray != null) {
        mTexCoordArray.clear();
    }
    if (mVertexArray != null) {
        mVertexArray.clear();
    }
}
```

**`EditFaceFragment.java` 中进行释放**

```java
public void backToHome(AvatarPTA avatarP2A) {
    helper.clearRevoke();
    mActivity.showHomeFragment();
    mAvatarHandle.setNeedFacePUP(false);
    mActivity.setCanController(true);
    mFUP2ARenderer.setFUCore(mP2ACore);
    mAvatarHandle.setAvatar(avatarP2A);

    mEditFaceParameter.release();
    EditFacePointFactory.release();
    EditParamFactory.release();

}
```

#### 修复内部类持有外部类引用导致的内存泄露

`TextDriveFragment.java`

```java
private void initSta() {
    mAliTtsHandler = new AliTtsHandler();
    mAliTtsCallback = new AliTtsCallback(this);
    mMediaPlayerHandler = new MediaPlayerHandler(mActivity);
    mExpressionList = new ArrayList<>();
    mMediaPlayerHandler.initPlayer(TYPE_PLATFORM, ttsPreparedListener, ttsCompletionListener, ttsErrorListener);
}

private static class AliTtsCallback implements AliTtsHandler.OnTtsCallback {

      private final WeakReference<TextDriveFragment> textDriveFragmentWeakReference;

      public AliTtsCallback(TextDriveFragment textDriveFragment) {
          textDriveFragmentWeakReference = new WeakReference<>(textDriveFragment);
      }

      @Override
      public void onSuccess(File wavFile, List<float[]> expressionList) {
          TextDriveFragment textDriveFragment = textDriveFragmentWeakReference.get();
          if (textDriveFragment != null) {

              textDriveFragment.mExpressionList.clear();
              textDriveFragment.mExpressionList.addAll(expressionList);
              textDriveFragment.mActivity.runOnUiThread(new Runnable() {
                  @Override
                  public void run() {
                      textDriveFragment.mMediaPlayerHandler.setDataSource(wavFile.getAbsolutePath());
                  }
              });
          }
      }

      @Override
      public void onFailure(String error) {
          TextDriveFragment textDriveFragment = textDriveFragmentWeakReference.get();
          if (textDriveFragment != null) {
              textDriveFragment.mActivity.runOnUiThread(new Runnable() {
                  @Override
                  public void run() {
                      ToastUtil.showCenterToast(textDriveFragment.mActivity, error);
                  }
              });
          }

      }
  }


public static class TTSCompletionListener implements BaseMediaPlayer.OnCompletionListener {

        @Override
        public void onCompletion(BaseMediaPlayer player) {
            Log.i(TAG, "onCompletion() called");
        }
    }


    public static class TTSErrorListener implements BaseMediaPlayer.OnErrorListener {

        @Override
        public void onError(BaseMediaPlayer player, int type, String message) {
            Log.e(TAG, "onError() called with: type = [" + type + "], message = [" + message + "]");

        }
    }

    public static class TTSPreparedListener implements BaseMediaPlayer.OnPreparedListener {

        private final WeakReference<TextDriveFragment> bodyDriveFragmentWeakReference;

        public TTSPreparedListener(TextDriveFragment textDriveFragment) {
            bodyDriveFragmentWeakReference = new WeakReference<>(textDriveFragment);
        }

        @Override
        public void onPrepared(BaseMediaPlayer player) {
            Log.i(TAG, "onPrepared() called");
            TextDriveFragment textDriveFragment = bodyDriveFragmentWeakReference.get();
            if (textDriveFragment != null && textDriveFragment.mPTATextDriveCore != null && textDriveFragment.mExpressionList != null) {
                textDriveFragment.mPTATextDriveCore.startPlay(textDriveFragment.mExpressionList);
            }
        }
    }

```

**`AndroidMediaPlayer.java` 取消监听注册**

```java
@Override
public void release() {
    mMediaPlayer.setOnCompletionListener(null);
    mMediaPlayer.setOnPreparedListener(null);
    mMediaPlayer.setOnErrorListener(null);
    if (state >= STATE_INITIALIZED) {
        mMediaPlayer.release();
        mMediaPlayer = null;
        state = STATE_RELEASED;
    }
    clearListener();

}
```

**`BaseMediaPlayer.java` 去掉无效参数**

```java
public static BaseMediaPlayer createPlayer(int type) {
    switch (type) {
        case BaseMediaPlayer.TYPE_PCM:
            return new PcmPlayer();
        case BaseMediaPlayer.TYPE_PLATFORM:
            return new AndroidMediaPlayer();
        default:
            return new AndroidMediaPlayer();
    }
}
```

**`AliTtsHandler.java` 去掉无效参数**

```java
public AliTtsHandler() {
    aliTtsCallback = new AliTtsCallback();
    initTts();
}
```

**`MediaPlayerHandler.java` 对context进行软引用的包装**

```java
private final WeakReference<Context> contextWeakReference;

public MediaPlayerHandler(Context context) {
    contextWeakReference = new WeakReference<Context>(context);
}
mBasePlayer = BaseMediaPlayer.createPlayer(playerType);
```

#### 将 `LoadingDialog` 的继承类改为 `Dialog` ，避免 `DialogFragment` 引起的内存泄露

具体请看 `LoadingDialog.java` 跟 `LoadingLayout.java` 的修改，建议直接覆盖文件，然后修复对应报错的地方。

#### 设置关键字来调试是否需要重新进入SDK首页

**`FUApplication.java` 新增 `needRestartMainActivity` 字段来表示是否需要重复进入SDK**

```java
public static final boolean needRestartMainActivity = true;
// 如果需要重复进入的话，这里可以不初始化client库，等到选择风格界面进行初始化
if (!needRestartMainActivity) {
    PTAClientWrapper.setupData(this);
}
```

**`SelectStyleActivity.java` 选择是否需要关闭当前界面**

```java
if (!FUApplication.needRestartMainActivity) {
    finish();
}
```

**`StyleSwitchUtil.java` 是否需要重复初始化client库，client库被销毁的话，需要重新初始化**

```java
//初始化P2A Client
if (FUApplication.needRestartMainActivity) {
    PTAClientWrapper.setupData(context);
}
```

**`MainActivity.java` 是否需要直接关闭界面还是回退到风格选择界面**

```java
@Override
public void onBackPressed() {
    if (mBaseFragment != null) {
        if (!isCanClick) {
            ToastUtil.showCenterToast(MainActivity.this, "模型载入中，请稍后...");
            return;
        }
        mBaseFragment.onBackPressed();
        return;
    }

    FilePathFactory.clearCache();
    ColorConstant.release();

    if (FUApplication.needRestartMainActivity) {
        FUPTAClient.isCoreInit = false;
        FUPTAClient.isStyleInit = false;
        onFinish();
    } else {
        finish();
        android.os.Process.killProcess(android.os.Process.myPid());
        Runtime.getRuntime().gc();
    }
}
```



#### 将 `setImageResource` 方法替换成了 `Glide.load`

`ItemAdapter.java` 、`AvatarFragment.java` 、`BodyDriveFragment.java` 、`GroupPhotoAvatar.java`

#### 说明

我们在做了大量的试验，进入我们的Demo页面退出以后，数据维持在150M以下属于正常范围。主要是由于Native层跟Graphics层占用的内存居多。

Native层的内存开辟在磁盘空间中，第一不会对内存（ROM）有太大的影响，所以不需要担心因为Demo的Native层内存导致应用OOM；第二，在Android8.0版本及其以后会将图片的内存放置到Native层，所以Android8.0的手机相对于之前版本的手机Native层所占用的内存会多一些。在我们做了大量的重复试验发现，当我们回退到风格选择界面的时候，Native层可能会在接下来的2-3分钟之内下降，所以我们猜测在进入一个页面的时候，系统也会缓存部分内存到Native层，并不完全是Demo中的代码导致的，毕竟新项目里面也做有20M左右的Native层的内存占用；第三，我们这边使用了Android7.0的手机测试过，Native层的内存大约在20-30M，

Graphics层内存：通过官方解释是跟GLSurfaceView、GLTexture有关系，但是我们可以创建一个新的项目来验证，就算项目里面没有任何关于GLSurfaceView、GLTexture的东西，还是会有20M左右的Graphics层内存，所以官方说话可能并不是很准确。从Demo首页回退到Demo的风格选择页面，Graphics层内存占用大致为50-70M，可能您觉得这个内存有点高了，但是如果您这边息一下屏幕就会发现Graphics层内存会下降很多。但是我们在实际项目中不可能让用户这边在退出相芯SDK的时候去息屏回收内存的，不要紧，我们这边又通过采用跳转空白Activity来确认Graphics层内存是可以回收的（跳转到空白Activity后回退到风格选择界面后Graphics层内存大约占用20-30M）。通过息屏跟跳转空白界面以后的Graphics层内存占用，我们可以大胆的猜测，<font color="#999999">被回收的Graphics层内存极有可能是系统用来缓存之前Activity的屏幕像素内存的</font> ，所以这部分内存也是被允许存在的，毕竟是系统管理的。（灰色部分字仅供技术人员参考，没有找到关于对这方面的权威说明，只是相芯开发这边通过多次试验得出的结论）

#### 数据提示

第一次进入Demo的风格选择界面，内存占用大约有110M左右，所以进入Demo首页退出到风格选择界面后有140-150M内存应该也属于合理范围，毕竟系统还要插一手内存。

新建空项目的时候，大约有60M左右的内存占用。